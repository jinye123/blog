---
title: vite
description: 深入理解 vite 的基础知识
date: 2024-01-20
tags: ['index']
---
# 构建工具

## 模块化规范有哪些？
前端模块化方案主要包括以下几种：

1. **CommonJS**：这是Node.js中广泛使用的模块化规范，主要用于服务器端的JavaScript。CommonJS使用`require`函数引入模块，使用`module.exports`导出模块。

2. **AMD（Asynchronous Module Definition）**：AMD是为了在浏览器中异步加载模块而设计的一种规范。RequireJS是AMD的一个实现。AMD使用`define`函数定义模块，使用`require`函数引入模块。

3. **CMD（Common Module Definition）**：CMD是另一种在浏览器端异步加载模块的规范，通常与Sea.js一起使用。

4. **UMD（Universal Module Definition）**：UMD是为了兼容CommonJS和AMD而设计的一种模块化规范。它同时支持同步和异步加载模块，适用于浏览器和服务器端。

5. **ES6 Modules**：ES6引入了原生的模块化语法，是目前最推荐使用的模块化方案。ES6模块使用`import`引入模块，使用`export`导出模块。

这些模块化方案和工具共同构成了前端模块化开发的丰富生态，使得开发者可以根据项目需求和环境选择合适的模块化方案。

## 什么是bundle？
**bundle** 是一个或多个模块（例如 JavaScript 文件、图片、CSS 文件等）被打包在一起后生成的输出文件。这个输出文件通常是一个 JavaScript 文件，但也可以是其他类型的文件，比如 CSS 或者 HTML。

Bundle 的概念可以分解为以下几个要点：

1. **模块化**：在 Webpack 中，一切皆模块。这意味着你的应用程序可以被分解成许多小的、可管理的模块，每个模块负责应用程序的一个特定功能。

2. **依赖关系**：Webpack 通过分析模块之间的依赖关系来确定哪些模块需要被包含在最终的 bundle 中。这通常是通过模块导入语句（如 `import` 或 `require`）来实现的。

3. **打包过程**：Webpack 会递归地构建一个依赖图，然后根据这个图来打包所有依赖的模块。这个过程涉及到解析模块、处理模块（可能包括编译、压缩等）、优化模块，并将它们打包成一个或多个 bundle。

4. **加载和执行**：浏览器加载这些 bundle，并在运行时解析和执行它们。由于所有依赖都被打包在一起，因此可以减少 HTTP 请求的数量，从而提高页面加载速度。

5. **代码拆分**：Webpack 支持代码拆分（code splitting），这意味着可以将应用程序的不同部分打包到不同的 bundle 中。这样，只有在需要时才会加载特定的 bundle，从而进一步优化加载时间和性能。

6. **懒加载**：与代码拆分相关，Webpack 允许你实现懒加载（lazy loading），即在需要时才加载某些模块，而不是在页面加载时一次性加载所有模块。

7. **优化**：Webpack 提供了许多优化工具，比如树摇（tree shaking）来移除未使用的代码，以及各种 loader 和 plugin 来进一步优化打包后的文件。

总的来说，bundle 是 Webpack 处理和优化你的应用程序代码的结果，它使得应用程序的部署和加载更加高效。

## 什么是bundle-less？
bundle-less 是一种前端开发架构，它主要依赖于浏览器对esm的支持，方案迎合了时代 时代造就了方案,它的核心思想是减少或消除传统意义上的打包（bundle）过程，让浏览器直接加载项目中的单个文件，而不是一个或多个打包好的 bundle 文件。这种架构的主要优势包括：

1. **快速启动和热更新**：在 bundle-less 的架构下，项目启动和文件变更时，只需要处理单个文件，不需要重新打包整个项目，从而实现极快的本地启动速度和代码编译速度。

2. **时间复杂度**：bundle-less 架构下，项目开发构建的时间复杂度始终为 O(1)，使得项目能够持续保持高效的构建。

3. **简化调试**：在 bundle-less 架构下，调试体验更加简单，不再强依赖 sourcemaps 即可实现稳定的单文件的 debug。

4. **利用浏览器能力**：bundle-less 架构充分利用浏览器自主加载的特性，跳过打包的过程，使得项目启动时获取到极快的启动速度，在本地更新时只需要重新编译单个文件。

5. **模块动态加载**：实现 bundle-less 的一个很重要的基础能力是模块的动态加载能力，可以利用 System.js 之类的 ES 模块加载器，或者直接利用 Web 标准的 ESModule。

6. **开发工具支持**：社区中出现了很多基于 ESModule 的开发工具，如 Vite、Snowpack、es-dev-server 等，这些工具支持 bundle-less 开发模式。

7. **未来趋势**：随着浏览器内核和 Web 标准的不断统一，前端的代码可以不再打包直接运行将成为可能，这将进一步提高整体的研发效率。

bundle-less 架构通过减少构建过程中的代码转换，极大地提升了开发过程中的构建速度，并且可以更好地利用浏览器的相关开发工具，是一种面向未来的前端开发模式。

## vite的特点？
1. 使用简单 封装集成的很多的预配置
2. 使用很快 得益于esm和esbuild
3. 扩展很多 兼容rollup大部分插件和可以自定义扩展

### 使用简单
vite没有复杂晦涩的配置，vite是一个更加集成化的构建平台，更合适的对比是基于webpack的高层工具如：
1. vue/cli 需要configWebpack和chainWebpack
2. cra 需要eject webpack的配置文件 
最终还是要修改webpack的配置文件，需要一定的学习成本。

vite有自身的插件系统，而且在生态兼容rollup插件，让viet在一开始就有非常强大的能力。

## vite与其他工具的区别
vite相对于webpack来说是一个梗高级别的工具
1. webpack更全面
2. vite 更好用

vite是为了项目而生额不是为了js构建而生，减少了很多配置项目。 
1. dev server vite的核心就是开发服务器
2. 不需要去配置loader，通过预设插件的形式内置了
3. 内置了build等打包多的方式

## hmr的原理
热更新是根据不同的框架去实现的不是一个通用的实现方式，在vite中是自己去实现的这个机制，因为esbuild和rollup只关心打包。
主要是借助于websocket当服务端的文件更新时会浏览器端的去重新请求这个文件，然后去动态到的更新这个内容，在vite中是通过vite-plugin-vue把热更新代码注入到客户端。

## 预编译
浏览器的esm的模块方式是不根据文件的依赖自动引入node_module的第三方库，因为会根据这个依赖图谱会产生大量的文件请求和非esm的引入报错。
1. 找到依赖关系使用esbuild把第三方库的模块化方式转换为esm的模块引入方式，编译后的文件放在node_module下面的.vite目录下。
2. 对引入node_module三方模块的文件的引入方式进行编译指向到.vite目录
3. 把所有分散的文件打包成一个bundle，当引入lodash的时候，有多个文件多个请求，打包到一个包的话可以优化文件的请求。

## 开发服务器
编译原理就是读取文件获取到代码字符串，然后对代码字符串做一系列的操作
# Babel 原理吧
estree 规范 acorn
三部分
1. 解析 将代码转换成 AST
   1. 词法分析: 将代码 (字符串) 分割成 token 流，即语法单元成数组
   2. 语法分析: 分析 token 流 并生成 AST
2. 转换: 访问 AST 节点 变换操作生成新的 AST
3. 生成:以新的 AST 为基础生成代码


## 构建产物
产物的构建不依赖于打包工具，而是依赖于**编译**工具，构建工具在打包的时候如果遇到不能处理的文件就需要借助编译工具去处理。
1. 在webpack中打包需要各种的loader
2. 在vite中打包需要各种的plugins

与webpack相比vite在构建的时候不会主动去处理js文件，因为借助浏览器的esm机制，遇到原生浏览不识别的文件需要使用各种工具进行编译打包。（bundle-less）
构建的应用资源有如下：
1. js (js,ts,jsx) 使用esbuild进行编译处理
2. css (less,scss,styles) 使用postcss进行编译处理
3. vue,png,jpg,webp,svg,字体 使用专门的编译工具进行处理 **vite-plugin-xx**
使用插件化机制来实现的不同资源的具体的打包工作。

## 构建优化
### 开发环境
1. 缓存已经编译得内容
2. 增量编译新增的内容
3. hmr 
esbuild打包的缺点 1. 不去处理dts文件 2.不支持到es5
### 生产环境
1. 使用rollup打包
优化都是构建工具自己去处理 tree-shaking chunk-split

构建工具的代码其实并不多，借助第三方工具去实现，主流程的梳理和把握住开发环境和生产环境的一致性

## 插件设计
1. 插件的协议
2. 插件的基座
3. 插件的执行

## vite的构建过程和实现原理
Vite 利用原生 ES 模块（ESM）在浏览器中提供模块热更新（HMR），这使得开发体验更加快速和流畅。

开发时构建过程
1. 初始化项目：读取并且解析vite.config.js配置文件
2. 启动开发服务器：开发服务器通常基于 Koa 框架构建，负责监听浏览器的请求，并根据请求的内容提供相应的服务
3. ESM的支持：利用浏览器的原生ESM进行模块加载。
4. 按需编译：实时编译请求的模块。
5. 热模块替换（HMR）：Vite 会重新编译该模块，并通过 WebSocket 等通信方式将更新后的模块发送给浏览器。浏览器接收到更新后的模块后，会替换掉原来的模块，从而实现页面的实时更新 。
6. source map：自动生成source map便于调试

生产时构建过程
1. 初始化项目：读取并且解析vite.config.js配置文件
2. 解析入口模块：当用户访问应用程序时，Vite 会解析入口模块（通常是 index.html）。使用rollup分析该模块的依赖关系。
3. 插件处理：使用插件系统进行代码转换，压缩和资源处理。
4. Tree Shaking：通过静态分析，移除未使用的代码，减少打包体积 。
5. 代码分割：Vite 会根据模块间的依赖关系进行代码分割，以减少初始加载时间 。
6. 资源优化：包括 CSS 提取、图片压缩、代码混淆等优化步骤 。
7. 策略缓存：为静态资源添加内容哈希，便于缓存管理。
8. 文件输出：打包生成最终的文件。


## 设计一个构建工具的
需要去解决前面存在的问解决疼痛点
1. 快速开发启动：理由esm模块加载，减少服务启动时间 （webpack）
2. hmr：支持快速反应更改，无需重新加载整个页面
3. 插件还架构：允许通过插件扩展功能，提高工具的灵活性和扩展性
4. 生产构建优化：利用像是rollup这样的高级打包工具进行代码的拆分、压缩和优化
5. 编译能力：编译工具的tree shacking、code split、source map
6. 运行时优化：模块的缓存压缩等

## vite的特点有哪些
### 为什么启动更快
1. 依赖: 第三方依赖使用esbuild（go）预构建,既可以解决cjs、umd、amd等多种模块化统一为esm，又可以解决esm的浏览器策略不引用node_module的问题，打包到.vite目录下
2. 源码: jsx、css、vue等以原生ESM方式提供源码，根据浏览器的请求动态的对源码时进行转换并按需提供编译后的代码，同时进行编译的缓存方便后续优化请求速度。


## vite兼容rollup的plugin有哪些
启动时的钩子
1. options
2. buildStart
转换时的钩子
3. resolveId 找到对应文件
4. load  加载对应文件
5. transform 转换代码
结束时的钩子
6. buildEnd
7. closeBundle